% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}
%
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{positioning, shapes.geometric}
\usepackage{adjustbox}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
%\usepackage{color}
%\renewcommand\UrlFont{\color{blue}\rmfamily}
%\urlstyle{rm}
%
\begin{document}
%
\title{Challenges and Solutions of Developing and
	Implementing a Novel Desktop-as-a-Service}
%
\titlerunning{Challenges and Solutions of Developing and
	Implementing a Novel DaaS}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Christian Baun \and
	Johannes Bouché}
% \author{Christian Baun\orcidID{0009-0004-9955-3752} \and
% 	Johannes Bouché\orcidID{TODO}}
%
\authorrunning{C. Baun, J. Bouché}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Faculty of Computer Science and Engineering,\\
	Frankfurt University of Applied Sciences,\\
	Nibelungenplatz 1, 60318 Frankfurt am Main, Germany
	\email{[christianbaun|johannes.bouche]@fb2.fra-uas.de}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
Desktop-as-a-Service (DaaS) is a cloud service category with tremendous potential for improving the everyday work of running and using applications. However, existing DaaS solutions have several drawbacks, which have limited the popularity of this service category in the past. Our novel DaaS solution, DESIGN, overcomes existing solutions' limitations and offers significant benefits. It can potentially revolutionize how we use applications, supporting non-modified Linux and Windows applications with just a browser on the client side. This paper describes some of the knowledge we gained during the development because of the challenges we faced and the solutions we found.

	\keywords{DaaS \and Compatibility \and Performance \and Stability \and Usability}
\end{abstract}
%
%
%
\section{Introduction}


This paper discusses challenges during the development and implementation of a novel Desktop-as-a-Service (DaaS) solution called DESIGN that enables the deployment and usage of unmodified Linux and Windows applications in the same way as web applications and can run inside public resources but can also be deployed in a private context. Since all interaction with DESIGN and the applications inside is done via a user's web browser, the users can use any client, no matter what hardware or host operating system it is compromised of. A browser is the only software component required to use the novel DaaS service.

Undoubtedly, developing a feature-rich DaaS system is a complex task, riddled with numerous obstacles and challenges. This paper meticulously categorizes these challenges into compatibility, performance, stability, and usability. It brings these obstacles to light and presents the solutions we devised to overcome them, along with the valuable lessons we learned in the process.

This document is structured as follows. Section~\ref{sec:relatedworkAbschnitt} discusses related work on DaaS solutions from an academic perspective, whereas section~\ref{sec:RecommendDaaSarchitecture} describes the state-of-the-art DaaS architecture DESIGN we designed and implemented. Section~\ref{sec:AnalysisPossibleComponents} presents the most relevant challenges we faced, analyses our options for handling these, and describes the solution we found. Finally, section~\ref{sec:Conclusions} discusses conclusions and includes directions for future work.


% TODO: Christian (1)
% TODO: Johannes (2)

\section{Related Work}
\label{sec:relatedworkAbschnitt}
% TODO:  Introduce: Infratstructure-as-a-Service  and others (IaaS, PaaS, SaaS, DaaS)
% TODO: Christian (1)
% TODO: Johannes (2)


DaaS has been a well-known service category since the emergence of cloud computing. Still, it got much less attention in research and literature.
The challenges and obstacles when developing DaaS solutions, rather than infrastructure (IaaS) and platform services (PaaS), have seldom been discussed in the literature.

Celesti et al.~\cite{celesti2016improving} implemented in 2016 a DaaS using the IaaS solution OpenStack~\cite{sefraoui2012openstack} and analyzed the characteristics and performance aspects of using noVNC, which is a client for the protocol Virtual Network Computing (VNC) that is implemented in the Hypertext Markup Language (HTML) and JavaScript, the protocol SPICE (Simple Protocol for Independent Computing Environments), and the remote desktop gateway Apache Guacamole as solutions for providing access to the desktop via a browser. One focus of the paper is the redirection of the sound interface of the virtual desktop. The paper's authors conclude that Guacamole, in combination with the Remote Desktop Protocol (RDP), is the best solution. The authors evaluated the lag time for remote audio playback in an Internet scenario by measuring the time between the automated initiation of the live streaming using the media player software VLC and the arrival of the music data by analyzing network traffic via monitoring software Wireshark. When using Guacamole combined with the protocol RDP, the average lag was around 750\,ms. When using Guacamole combined with the protocol VNC, the average lag was around 1750\,ms. The paper also includes a short evaluation of the lag for video frames represented by background color changes of a Java application. Again, the configuration Guacamole and RDP offered the best performance video update with an average lag of around 300\,ms. The configuration of Guacamole and VNC caused an average lag of around 500\,ms.

Magana et al.~\cite{magana2019remote} compared in 2019 the most popular remote desktop protocols and software implementations. The authors analyzed five protocols: PCoIP used in the Amazon WorkSpaces, RDP, TeamViewer, VNC, and Citrix Independent Computing Architecture (ICA). In the paper, the network transfer rate and its relation to the quality experienced by the DaaS user are evaluated by assuming three scenarios: using an office software suite, web browsing, and video streaming. One emphasis of the paper is comparing the transfer rate of the different protocols for three scenarios. In the Office Software Suite scenario, the transfer rate is measured and compared when performing several different tasks like opening and editing a document (typing), loading an image, and saving a document. The web browsing scenario covers requesting three different web pages, and for the video streaming scenario, the same YouTube video file was viewed at different resolutions. The authors conclude that RDP requires fewer downstream and upstream network resources for all three scenarios. It is important to understand that the protocols RDP and VNC are implemented in open-source projects and proprietary solutions for many different operating systems. Depending on the different quality levels of the many existing implementations, it is difficult to generalize about the performance of the protocols, as individual implementations may have better or worse performance characteristics than expected.

Several works in literature have analyzed the latency of Cloud gaming services that have, in some aspects, similar requirements to DaaS offerings. According to Lampe et al.~\cite{lampe2014assessing}, the latency of locally executed games is compromised of the following components:

\begin{itemize}
	\item Input lag caused by the controller device (e.g., mouse or keyboard).
	\item CPU time for processing the user input and the program itself.
	\item GPU time of the graphics processor for rendering the next frame.
	\item Time required for delivering the frame into the frame buffer.
	\item LCD response time (time required to display the frame on the screen).
\end{itemize}

In cloud gaming scenarios, the following components increase latency further:

\begin{itemize}
	\item Transfer time (upstream) for sending the user input to the service provider.
	\item Time required for capturing the frames and encoding it as a video stream.
	\item Transfer time (downstream) for sending the video stream to the client.
	\item Time required for decoding the video stream back into a frame.
\end{itemize}

For every deployment scenario or cloud service category possible, users expect a latency value that is not annoying when interacting with the service and its applications. Choy et al.~\cite{ChoyWongSimonRosenberg2012}, Claypool et al.~\cite{claypool2010latency}, and Jarschel et al.~\cite{jarschel2011evaluation} consider a maximum tolerable latency, based on subjective tests, being around 100\,ms. This relatively low value sets the demand for a fast network interaction between client and service and limits their maximum distance. As mentioned in Clincy et al.~\cite{clincy2013subjective}, The former cloud gaming service provider OnLive specified in the year 2010 that the distance between the service provider and the consumer should not be greater than 1000 miles (approx. 1600\,km) because otherwise, the round-trip communications delay time between will be too long for video games.

On first thought, the latency requirements of a modern computer game are hardly the same as those of a desktop application. However, just as with computer games, the lagging operation of desktop programs has a negative impact on the user experience, and with video conferencing or other graphics-intensive applications, the utilization of resources and latency requirements are very similar to computer games.

\section{Architecture}
\label{sec:RecommendDaaSarchitecture}
% 
% TODO: Christian (1)
% TODO: Johannes (2)

Figure~\ref{figure_architecture} shows the architecture of our novel DaaS solution DESIGN that can run unmodified Linux and Windows applications in Linux containers (Linux and Windows applications compatible with Wine) and virtual machines (Windows applications incompatible with Wine).


\begin{figure}
	\centering
	\includegraphics[width=.75\linewidth]{images/DaaS_DESIGN_Architecture_v12_english.pdf}
	\caption{Architecture of the novel DaaS DESIGN~\cite{OJCC_2023v8i1n01_Baun}.} 
	\label{figure_architecture}
\end{figure}

The open-source server virtualization platform Proxmox VE runs bare-metal and offers virtual machines with the Kernel-based Virtual Machine (KVM) and container-based virtualization via LXC Linux container. Since the LXC API is, in comparison to the Docker API, rather poorly documented and lacks several features, we considered Docker a better container virtualization solution. A deployment of docker directly in the host-operating system or inside a virtual machine is both possible.

Exporting the graphical user interface of Linux and Windows applications, is possible using the a protocols VNC or RDP. Free server implementations exist for both operating system families. Since the focus of our DaaS solution is to export only the application's graphical user interface and not full desktops -- a feature not all server implementations include -- is the number of available projects and solutions limited. For Linux containers, the free software projects x11vnc and Xrdp can be used in the DESIGN DaaS. For Windows VMs, the free software TightVNC and the Windows-internal RDP server can be used.

One of the main goals of DESIGN is to allow all interactions to be carried out solely by using a browser. Thus, a broker or proxy software that mediates between the VNC or RDP implementation and the browser is required. The most advanced solution available is the free software project Apache Guacamole which supports VNC and RDP both and includes further relevant features regarding sound and printing.

The core components of DESIGN are our self-developed Web UI and the Control Application, which carry out the communication between all service components.

When starting a virtual machine or container instance, it automatically includes an SSH service. Our self-developed instance component waits until the SSH service is ready to satisfy requests. In case applications are to be started or modifications are to be carried out, the instance component sends these requests to the virtual machine or container. Modification requests include resolution changes and fetching host status information.

In general, the self-developed instance component allows users to carry out essential administration and usage tasks that the operating system does not offer via a generalized API.

% TODO: Die letzten 3 Abschnitte noch überarbeiten und präzisieren


\section{Challenges and Solutions}
\label{sec:AnalysisPossibleComponents}

% TODO: Christian (1)
% TODO: Johannes (2)

While developing the novel DaaS platform DESIGN, we faced multiple obstacles and challenges. Each of these issues belongs to one of these four categories: compatibility, performance, stability, and usability. This section presents the issues we were confronted with, the possible approaches we analyzed, and the solutions we chose.

\subsection{Compatibility}
% 
% TODO: Christian (1)
% TODO: Johannes (2)

The first relevant characteristic of a DaaS that a user is confronted with is the list of compatible applications. In the best case, all applications of all popular operating systems can be integrated and used with such a novel platform. Several DaaS projects and solutions from the last two decades and similar concepts like web desktops or webtops lacked native support for popular applications.

Examples worth mentioning in this context include eyeOS and SilveOS. The project eyeOS~\cite{liu2012research,vidyabanu2011implementation} which simulates a desktop environment using HTML, the scripting language PHP, JavaScript, and the MySQL database management system. The project SilveOS~\cite{garmpis2016design} mimics the look and feel of a Windows desktop in the browser using the discontinued application framework Microsoft Silverlight. Despite being free software, both solutions have never become widely used since it is impossible to import and use native Windows or Linux applications there. All required applications have to be developed as web applications. This limitation caused most potential users to lose interest in web desktops because many popular native applications can hardly be replaced or re-developed, and many feature-rich and well-established Software-as-a-Service (SaaS) offerings like Microsoft Office 365 and Google Docs already exist.

A new DaaS is only accepted by a broad user group if it enables the integration of native applications in an unchanged manner. It is also desirable that a DaaS supports Linux and Windows applications both to enable flexible working and make the operation of a virtualization solution on the desktops unnecessary. Ideally, it should also be possible to run native Mac OS applications. However, this goal is difficult to achieve under legal conditions due to the Mac OS operating system's licensing restrictions.

Further essential features for most users are printing, sound, and compatibility with external storage media.

Guacamole supports redirecting audio, printing, and disk access via the protocol RDP. The printing feature does not allow access to local or remote printers; instead, it allows users to print directly to PDF files, which are received by the user's web browser. As a prerequisite, the GhostScript interpreter must be deployed on the Guacamole server. File transfer over RDP supports Guacamole by emulating a virtual disk drive that persistently stores data on the Guacamole server.~\cite{ApacheGuacamole2024}

Compared to RDP, the protocol VNC offers fewer features in Guacamole since it does not support sound on its own. However, Guacamole supports sound using PulseAudio\footnote{On Linux operating systems, sound and microphone devices are accessed via sound servers like PulseAudio and PipeWire, which interact with the sound interface present in the kernel, e.g., Advanced Linux Sound Architecture (ALSA) or Open Sound System (OSS)} as a workaround solution. VNC also does not offer file transfer and access to external storage media, but as a workaround solution, Guacamole supports file transfer file transfer via the SSH File Transfer Protocol (SFTP) which is an extension of the Secure Shell protocol (SSH).



\subsection{Performance}
% Initial brainstorm:
% + Welche Performance-Paramter / Kriterien sind hier relevant für die Anwendung / Nutzung
% + Fokus: Bottlenecks, Möglichkeiten der Performance-Steigerung, Grenzen/Limits, die man akzeptieren muss
% + Latenz hängt auch immer von Entfernung und Übertragungsmedium ab.
% + Skalierbarkeit: Stand und Möglichkeite
% + Ceph-Dateisystem
% + Datenbank SQlite aktuell. Perspektivisch MariaDB
% + Guacamole läuft 1x direkt auf dem Host aktuell. Läuft theoretisch auf jedem Host.
%
% Structure:
% performance of:
% - our serice itself
% - backend services
% - Viewer performance
% Limiting Factors
% - Hosting
% - Network
% - Internal data and communication
% Chosen techniques/solutions/protocols:
% - Filesystem (Ceph)
% - Database (sqlite, mariadb)
% - Guacamole (Proxy approach)
% Similar_Examples:
% - Cloud Gaming efforts 
%    - technical solutions, 
%    - latencies, 
%    - hardware support and integration)
%
% TODO: Johannes (1)
% TODO: Christian (2)
% TODO: Christian: Latenz bei Cloud-Gaming Erfahrungen
% TODO: 
%       - Include overall takeaway messages somewhere before:
%           - IaaS, PaaS and SaaS combined is defined as DaaS
%           - Define terms: Backend-service, Host-System, Instance
%           - We want a stable and usable system first, performance comes second
%           - Low effort to use and integrate is the most crucial aspect!!!
%           - No "Gamestation", but all modern applications shall be suported
%               - "Regular" office apps (Spreadsheets, Editor, Email, Filemanager)
%               - 3D modelling (Blender, Mayo, etc.)
%               - Audio/Video Editing? (kdenlive, Adobe Premiere, OBS?)
%               - Services (Webserver, Emailserver, Fileserver, etc.)
%           - If several solutions are plausible, implement all and let the user decide
%           - Give definitions for all specified daas-usecase
%       - More references
%       - Illustrate each subsection
%       - Typos, grammar, etc.

To describe the mission-critical performance aspects of the discussed system,
we initially provide a brief overview of potential challenges
by outlining bottlenecks and other relevant problem areas.
This is done in the context of the underlying use case model of DaaS systems.
Subsequently, we give a more comprehensive description
of our specific design decisions and tailored solutions.

Performance, from our viewpoint, stands out as the most crucial system property,
implying influence of other  relevant properties,
such as user experience, system responsiveness, and overall efficiency.
Consequently, we encountered multifaceted challenges
that potentially intersected across several layers within our architecture.

Hence, every component from the core infrastructure
to all backend services and user-facing elements,
must meet individual and domain-specific requirements
to contribute to the overall performance goals of the entire system.
Thus, we outline key limiting factors that hinder performance,
along with our experiences and the chosen mitigation strategies.

Given the absence of a generalized measurement system,
we ranked these factors based on their magnitude of impact,
drawing from our experiences obtained during the project.

% From our point of view, the three most critical performance aspects
% for Daas-Systems are:
% \begin{itemize}
% 	\item Infrastructure and Platform
% 	\item Network Latency and Bandwidth
% 	\item Internal Processing and Communication
% \end{itemize}
% Since each of them has their own characteristics,
% specific behavior and requirements, implying a potential impact
% on the overall system performance and resource utilization,
% we describe them individually and in more detail
% in the following separate subsections.



\subsubsection{Infrastructure and Platform}
In general can be said that the chosen infrastructure, platform,
and utilized software combined may have the most impact on the overall resource consumption
and are therefore of major importance.
As a DaaS system combines all aspects of IaaS-, PaaS, and SaaS-based computation
each individual performance characteristics has to be taken into account.


Regarding Infrastructure-as-a-Service (IaaS),
our solution generally offers the flexibility
to use either virtual machines or containers.
Scientific publications discussing relevant performance aspects of such systems
highlight the apparent advantage of a lightweight container solution
over virtual machines when identical programs are tested in both environments
~\cite{felter2015updated,potdar2020performance,seo2014performance}.

This suggests that a container-based approach is likely preferable
if the choice is available.
However, not every application can be run
in a container-based environment,
so we maximize coverage of potential usecases
by offering both container-based and virtual machine-based application hosting.

Regarding Platform-as-a-Service (PaaS),
studies show that there is no dramatic difference in performance
when derivatives of operating systems are compared to each other
~\cite{balen2020performance,boras2020performance}.
Nevertheless, some derivatives are more lightweight and performant.
In contrast, comparing operating systems of different types
reveals more obvious results, particularly when considering
low-level operating system functionality implementations
such as interrupt handling, memory allocation, and boot time
~\cite{sergeev2022docker,sulaiman2021comparison}.
Additional performance potentials can be leveraged
in cases where a Windows virtual machine can be replaced
with a container-based solution integrating wine
~\cite{huang2012performance}.  % win inside vm

For SaaS, performance largely depends on the underlying usage model
and the actual software being virtualized.
Depending on the use case, influential properties
such as multi-tenancy, provision strategies or the virtualized data type
might be utilized to varying degrees, resulting in overall
better or worse performing systems ~\cite{zhong2010virtualization}.

Despite the potential for usecase-specific optimization,
we emphasize that for DaaS systems,
coverage of a broad range of potential use cases is generally more favorable
than solving a particular use case in the most efficient way.
Therefore, we consider all user-facing desktop applications
as plausible candidates for migration to our systems,
rather than more complex distributed systems
for which a tailored environments might be more suitable.

Figure~\ref{hosting_scenarios} visualizes the available hosting startegies for our platform.
We aim to support any Windows or Linux-based application in virtual machines
and support any Linux- and Wine-based applications for container environments.

\begin{figure}
	\centering
	\begin{adjustbox}{width=\textwidth}
		\begin{tikzpicture}[every node/.style={minimum height=1cm, align=center}]
			%Type Column
			\node[minimum width=2cm] at (-4,-2) {IaaS};
			\node[minimum width=2cm] at (-4,-1) {PaaS};
			\node[minimum width=2cm] at (-4,0) {SaaS};
			\node[minimum width=2cm] at (-4,1) {DaaS};
			% DaaS
			\node[draw, minimum width=12cm, fill=gray!10] at (3,1) {DESIGN Frontend};
			%Linux
			\node[draw, minimum width=6cm, fill=gray!50] at (0,0) {Linux App};
			\node[draw, minimum width=6cm, fill=gray!80] at (0,-1) {Linux OS};
			\node[draw, minimum width=3cm, fill=gray!100] at (-1.5,-2) {Virtual Machine};
			\node[draw, minimum width=3cm, fill=gray!100] at (1.5,-2) {Container};
			%Windows
			\node[draw, minimum width=6cm, fill=gray!50] at (6,0) {Windows App};
			\node[draw, minimum width=3cm, fill=gray!80] at (4.5,-1) {Windows OS};
			\node[draw, minimum width=3cm, fill=gray!80] at (7.5,-1) {Linux OS, Wine};
			\node[draw, minimum width=3cm, fill=gray!100] at (4.5,-2) {Virtual Machine};
			\node[draw, minimum width=3cm, fill=gray!100] at (7.5,-2) {Container};
		\end{tikzpicture}
	\end{adjustbox}
	\caption{Application hosting strategies.}\label{hosting_scenarios}
\end{figure}

\subsubsection{Network Latency and Bandwidth}
Network Latency and Bandwidth are crucial factors
in delivering web-based access to DaaS apps,
directly impacting system responsiveness experienced by users.
Supporting standardized frame-buffer protocols enables user interaction initially
and provide additional access to external devices like printers or USB sticks.
In cases involving for example video content transmission,
network bandwidth often becomes the main bottleneck,
especially with high-resolution video streams.
In contrast to that,  when transmitting audio, mouse movements,
or keyboard inputs, network latency becomes more important.

Application-specific requirements can be managed to some extent
through protocol-inherent tuning parameters and compression algorithms.
Our solution therefore offers a range of tuning options
in order to adapt to different use cases
and empowering users to choose their own tailored solution.

We utilize the Guacamole desktop gateway implementation,
supporting widely-used frame-buffer protocols like VNC and RDP,
along with relevant tuning options.
Guacamole also enables audio support and integration with external devices
through a JavaScript-based web client (guacamole.js).
As depicted in figure~\ref{websocket_proxy},
the proxy component recives HTTP requests from the guacamole.js webclient
and forwarded by the backend by using regular WebSocket opcodes (Guacamole protocol).
Such communication is forwarded to the Guacamole daemon (guacd)
which in turn communicates to each instance
by using the frame-buffer protocol of choice (VNC or RDP).


However, integrating Guacamole into the system
requires consideration of additional factors besides the frame-buffer protocols itself.
Authentication mechanisms for example are particularly important in a DaaS context,
as users expect seamless authentication across the whole system
without multiple logins per session.
Additionally, safeguarding sensitive information like user passwords is crucial
for maintaining system security and user trust.
To mitigate the risk of unintended system manipulation, Guacamole was integrated
in a proxied approach and by using websockets.
This ensures that credentials of a generated instance remain secret to the host system
while still providing authorized, passwordless access to the hosted application.

Moreover, the proxy mechanism enables support for other additional features
such as dynamic desktop resizing.
While Guacamole offers support for that by default in RDP,
support is completely missing for the VNC protocol.
Nevertheless, the proxied approach enables to intercept all exchanged websocket opcodes
and by listening for size requests
the requested feature could be added
by directly interacting with the instance on another layer.

While these changes to the default Guacamole use case are necessary to align
with the underlying DaaS design requirements,
they also negatively impact overall system performance and responsiveness.
The integration as a proxy introduces additional network hops,
leading to noticeable delays in network communication.
Additionally, the protocol-level evaluation of opcodes further increases this delay,
potentially affecting perceived responsiveness
if resize requests take longer than expected.
However, despite the introduced overhead,
the solution still enables platform-independent
and seamless access for all defined DaaS use cases.

\begin{figure}
	\centering
	\begin{adjustbox}{width=\textwidth}
		\begin{tikzpicture}[every node/.style={minimum height=1cm, align=center}]

			% Nodes center row
			\node[draw, minimum width=3cm, fill=gray!10] (browser) at (0,0) {guacamole.js };
			\node[draw, minimum width=3cm, fill=gray!50] (back) at (4,0) {DESIGN Backend};
			\node[draw, minimum width=3cm, fill=gray!50] (proxy) at (8,0) {Proxy};
			\node[draw, minimum width=3cm, fill=gray!50] (guacd) at (12,0) {guacd};
			\node[draw, minimum width=3cm, fill=gray!100] (inst) at (16,0) {Instances};
			% Arrows center row
			\draw[<->, thick, black] (browser.east) -- (back.west);
			\draw[<->, thick, black] (back.east) -- (proxy.west);
			\draw[<->, thick, black] (proxy.east) -- (guacd.west);
			\draw[<->, thick, black] (guacd.east) -- (inst.west);
			% Upper row
			\node[draw, minimum width=3cm, fill=gray!10] (client-backend) at (2,2) {HTTP/WebSocket};
			\node[draw, minimum width=3cm, fill=gray!50] (backend-proxy) at (6,2) {HTTP/WebSocket};
			\node[draw, minimum width=3cm, fill=gray!50] (proxy-guacd) at (10,2) {Guacamole protocol};
			\node[draw, minimum width=3cm, fill=gray!100] (guacd-inst) at (14,2) {Framebuffer protocols/\\VNC,RDP};
			% Dashed lines upper row
			\draw[-, dashed, thick, black] (2,0) -- (2,1.5);
			\draw[-, dashed, thick, black] (6,0) -- (6,1.5);
			\draw[-, dashed, thick, black] (10,0) -- (10,1.5);
			\draw[-, dashed, thick, black] (14,0) -- (14,1.5);
			% Arrow bottom row
			\draw[<->, thick, black] (0,-1) -- (3.8,-1) node[midway, below, font=\footnotesize] {Client Communication};
			\draw[<->, thick, black] (4,-1) -- (11.8,-1)node[midway, below, font=\footnotesize] {Backend Communication};
			\draw[<->, thick, black] (12,-1) -- (16,-1)node[midway, below, font=\footnotesize] {Instance Communication};
		\end{tikzpicture}
	\end{adjustbox}
	\caption{WebSocket Proxy Components.}\label{websocket_proxy}
\end{figure}

\subsubsection{Internal processing and Communication}
Another critical aspect directly related to performance and responsiveness
is how data is internally processed, stored, and communicated
among all involved components and instances.
This includes metadata collected and processed by essential components
and involves direct exchange of raw data with object instances.

Ensuring a satisfying user experience in a DaaS system
implies specific components in a host system.
This includes access to all backend services
used to create containers and virtual machines,
local or remote databases, authentication services, filesystems, and network devices.
Additionally, a web server is integrated to provide relevant API endpoints
for frontend communication and websocket endpoints for viewer communication.

Generally spoken, all of these components can potentially become bottlenecks
when handling high throughputs or large amounts of concurrent applications
requiring low latency access and especially if all necessary backend components
are served from the same hardware.
Architecturally, all relevant components
must therefore be designed for distribution across different hosting systems.
However, retaining certain components directly on the host system
may still be required to ensure low-latency access.

From our observations, components requiring realtime and low-latency performance,
should physically be kept as close to the core hosting system as possible
as shown in figure~\ref{perf_internal_communication}.
This includes all data and communication relevant to
audio, video, mouse, and keyboard transmission,
as well as all backend services for hosting containers and virtual machines.
Ideally, these components should be hosted natively on the host system
for virtual network and hardware access
or at least be connected to the same physical network
in order to minimize network latencies.

Regarding other components such as database access,
authentication providers, and filesystems,
maintaining a close distance from the host is advisable,
but this depends largely on the total number of users
as well as their specific use cases.
On smaller scales, keeping these components
in close physical proximity to the host remains prudent.

\begin{figure}
	\centering
	\begin{adjustbox}{width=\textwidth}
		\begin{tikzpicture}[every node/.style={minimum height=1cm, align=center}]
			% Standalone Realtime
			\node[draw, minimum width=8cm, fill=gray!10] (singlefront) at (0,-0.5) {DESIGN Frontend};
			\node[draw, minimum width=8cm, fill=gray!30] (singleback) at (+0,-2) {DESIGN Backend};
			\node[draw, minimum width=4cm, fill=gray!100] at (-2,-3) {Infrastructure\\(Proxmox/Docker) };
			\node[draw, minimum width=4cm, fill=gray!100] at (-2,-4) {Proxy};
			\node[draw, minimum width=4cm, fill=gray!100] at (-2,-5) {Backend API};
			% Standalone Services
			\node[draw, minimum width=4cm, fill=gray!50] at (+2,-3) {Database};
			\node[draw, minimum width=4cm, fill=gray!50] at (+2,-4) {Filesystem};
			\node[draw, minimum width=4cm, fill=gray!50] at (+2,-5) {Authentication};
			%Standalone Caption
			\node[minimum width=8cm] (browser) at (0,-6) {Standalone};
			% Distributed Realtime
			\node[draw, minimum width=10cm, fill=gray!10] (distfront) at (10,-0.5) {DESIGN Frontend};
			\node[draw, minimum width=10cm, fill=gray!30] (distback) at (10,-2) {DESIGN Backend};
			\node[draw, minimum width=4cm, fill=gray!100] (inf) at (7,-3) {Infrastructure\\(Proxmox/Docker) };
			\node[draw, minimum width=4cm, fill=gray!100] (proxy) at (7,-4) {Proxy};
			\node[draw, minimum width=4cm, fill=gray!100] (api) at (7,-5) {Backend API};
			% Distributed Services
			\node[draw, minimum width=4cm, fill=gray!50] (db) at (13,-3) {Database};
			\node[draw, minimum width=4cm, fill=gray!50] (fs) at (13,-4) {Filesystem};
			\node[draw, minimum width=4cm, fill=gray!50] (auth) at (13,-5) {Authentication};
			% Network
			\node[draw, minimum width=1cm, minimum height=3cm, fill=white] (browser) at (10,-4) {N\\E\\T\\W\\O\\R\\K};
			% Distributed Caption
			\node[minimum width=10cm] (browser) at (10,-6) {Distributed};
			% Arrows back<->front
			\draw[<->, thick, black] (singleback.north) -- (singlefront.south);
			\draw[<->, thick, black] (distback.north) -- (distfront.south);
			% Arrows realtime
			\draw[<->, thick, black] (inf.east) -- ++(0.5,0);
			\draw[<->, thick, black] (proxy.east) -- ++(0.5,0);
			\draw[<->, thick, black] (api.east) -- ++(0.5,0);
			% Arrows services
			\draw[<->, thick, black] (db.west) ++(-0.5,0) -- ++(0.5,0);
			\draw[<->, thick, black] (fs.west) ++(-0.5,0) -- ++(0.5,0);
			\draw[<->, thick, black] (auth.west) ++(-0.5,0) -- ++(0.5,0);
		\end{tikzpicture}
	\end{adjustbox}
	\caption{Internal Communication Flow}\label{perf_internal_communication}
\end{figure}

\subsection{Stability}
% TODO: Johannes (1)
% TODO: Christian (2)
% TODO: Johannes: Beschreibung zur Position der Komponenten, Möglichkeiten der Parallelisierung und Einschränkungen
%
% Was ist hier relevant?
% Verfügbarkeit des Service und der Benutzerdaten
% Redundante Komponenten (Hardware und Software)
% Welche Komponenten kann man sinnvoll redundant vorhalten?
% Was sind die Vor- und Nachteile?
% Auch Kosten?
% Wo sehen wir aktuell in unserer Architektur Risiken für Dienstausfall und Datenverlust?
% Features von Proxmox
% Ceph-Dateisystem
% Datenbank SQlite aktuell. Perspektivisch MariaDB
% Guacamole läuft 1x direkt auf dem Host aktuell. Läuft theoretisch auf jedem Host. Proxmox kann sich darum kümmern?!
% Docker haben/nicht haben / Vor- und Nachteile
% Hier auch auf die Skalierbarkeit beziehen
% Structure:
%	- Stability
%		- Redundancy
%		- Scalability
%	- Backend-services
%		- Database
%		- Authentication
%		- Distributed Filesystem
%		- Container/VM (Proxmox, Kubernetes?) 
%		- Instance error => Recreate
%	- Considerations:
%		- TODO: Mention that term: Divide and conquer
%		- Requirement: Distributable components
%	- Risks:
%		- Filesystem error
%		- Database error
%		- Authentication error
%		- Infrastructure error (Container/VM)
%	- Benefits/Drawbacks:
%		- Distribution of components is distribution of load => Performance
%		- Eliminates bottlenecks
%		- Errors affect only errornous component

Stability in DaaS applications is especially important
for meeting the demands of continuous and time-critical operations
across diverse user scenarios.
Ensuring the stability of all system components during runtime is paramount
to maintain service continuity, handle growing user loads,
and transparently recover from failures
while providing a seamless end-user experience.
These considerations are integral to our architectural concept,
directly impacting the operational integrity of the system
and its suitability for enterprise-level deployment and trust.

This definition of stability is supported
by various architectural and operational strategies,
including component redundancy, node scalability,
and a robust backend service framework facilitating communication
between components and nodes.
These strategies, along with their drawbacks and benefits,
will be further explored at a component level
and within the following subsections.

\subsubsection{Scalability of Components}

Scalability in DaaS environments
can be approached through two fundamental methods: horizontal and vertical scaling.
Horizontal scaling, or scaling out, involves adding more machines or instances
to manage increased loads.
In contrast, vertical scaling, or scaling up,
adds more power (CPU, RAM) to existing machines
~\cite{vaquero2011dynamically}.
While horizontal scaling offers flexibility
and is often preferred in cloud environments,
vertical scaling remains important for applications
requiring strong single-thread performance or low latencies.

To comply with both approaches,
we designed the system and its backend services
to be split into logical units that can be distributed across dedicated systems.
Each backend service receives dedicated configuration
and can be accessed via hostname and port tuples.
By default, all backend services reside on the same host,
with tuples derived from the host configuration.
In a distributed context, services can be distributed to dedicated remote systems
to adhere to horizontal scaling principles.
Relevant tuples can then be derived from any node
using a common database containing meta information.

Vertical scaling of DaaS nodes is not currently planned,
but administrators are free to use custom third-party toolchains,
such as GPU virtualization, for vertical scaling on a per-host basis.
Although vertical scaling within a host
is beyond the scope of our research project,
scaling the instances hosted within the system is feasible for both dimensions.
For vertical scaling of instances, we provide appropriate parameters
and API endpoints to manipulate resource assignments,
allowing for arbitrary configurations.

For horizontal scaling of instances, the built-in mechanisms
of each backend service are automatically configured
and utilized to distribute instances across a pool of connected nodes.
For virtual machines, Proxmox implements such mechanisms
as part of its `Proxmox VE High Availability (HA)' cluster.
For containers, similar concepts can be integrated with any backend service,
such as Kubernetes.
Within these clusters,
DaaS instances are entirely agnostic to their hosting system
and only need to be reachable
via a known hostname or IP as a single requirement.
As shown in figure~\ref{scale_objects_horizontal},
we provide a globally maintained state of data, authentication and storage
which is accessible either by horizontally scaled backends and frontends
or otherwise,
by horizontally and vertically scaled instances in our DaaS object domain.


\begin{figure}
	\centering
	\begin{adjustbox}{width=\textwidth}
		\begin{tikzpicture}[every node/.style={minimum width=4cm, minimum height=1cm, align=center}]

			% User
			\node[draw, minimum width=4cm] (user) at (5,1.5) {User};
			% Clusters
			\node[] at (-5,-0.5) {Frontend Cluster\\(Horizontal)};
			\node[] at (-5,-2.5) {Backend Cluster\\(Horizontal)};
			\node[] at (-5,-4.5) {Object Domain\\(Horizontal and Vertical)};

			% Node1
			\node[draw, fill=gray!10]  (front1) at (0,-0.5) {DESIGN Frontend 1};
			\node[draw, fill=gray!30]  (back1)  at (0,-2.0) {DESIGN Backend};
			\node[draw, fill=gray!50]  (real1)   at (0,-3.0) {Realtime Components};
			\node[draw, fill=gray!100] (inst1)  at (0,-4.5) {DaaS Instance (ID=1234)};
			% Node2
			\node[draw, fill=gray!10]  (front2) at (5,-0.5) {DESIGN Frontend};
			\node[draw, fill=gray!30]  (back2) at (5,-2.0) {DESIGN Backend};
			\node[draw, fill=gray!50]  (real2) at (5,-3.0) {Realtime Components};
			\node[draw, fill=gray!100] (inst2)  at (5,-4.5) {DaaS Instance (ID=1234)};
			% Node3
			\node[draw, fill=gray!10]  (front3) at (10,-0.5) {DESIGN Frontend};
			\node[draw, fill=gray!30]  (back3) at (10,-2.0) {DESIGN Backend};
			\node[draw, fill=gray!50]  (real3) at (10,-3.0) {Realtime Components};
			\node[draw, fill=gray!100] (inst3)  at (10,-4.5) {DaaS Instance (ID=1234)};
			% Domain
			\node[draw, dashed, minimum width=14.5cm, minimum height=1.25cm]  (domfront) at (5,-0.5){};
			\node[draw, dashed, minimum width=14.5cm, minimum height=2.25cm]  (domback) at (5,-2.5){};
			\node[draw, dashed, minimum width=14.5cm, minimum height=1.25cm]  (dominst) at (5,-4.5){};
			% Backend Services
			\node[draw, minimum width=2cm, minimum height=5cm] (backends) at (14,-2.5){Backend\\Services};
			% Arrows back<->Inst
			\draw[<->, thick, black] (inst1.north) -- (real1.south);
			\draw[<->, thick, black] (inst2.north) -- (real2.south);
			\draw[<->, thick, black] (inst3.north) -- (real3.south);
			% % Arrows back<->front
			\draw[<->, thick, black] (front1.south) -- (back1.north);
			\draw[<->, thick, black] (front2.south) -- (back2.north);
			\draw[<->, thick, black] (front3.south) -- (back3.north);
			% % Arrows Insts
			\draw[<->, thick, black] (inst1.east) -- (inst2.west);
			\draw[<->, thick, black] (inst2.east) -- (inst3.west);
			% % Arrows User
			\draw[->, thick, black] (user.south) -- (front1.north);
			\draw[->, thick, black] (user.south) -- (front2.north);
			\draw[->, thick, black] (user.south) -- (front3.north);
			% % Arrows Backend
			\draw[<->, thick, black] (domfront.east) -- ++(0.75,0);
			\draw[<->, thick, black] (domback.east) --  ++(0.75,0);
			\draw[<->, thick, black] (dominst.east) --  ++(0.75,0);
		\end{tikzpicture}
	\end{adjustbox}
	\caption{DESIGN Component Scaling}\label{scale_objects_horizontal}
\end{figure}

\subsubsection{Redundancy of Backend Services}

Redundancy is crucial in distributed systems,
particularly in DaaS architectures,
to safeguard against service interruptions and data loss
by duplicating essential components, functions, and data.
This design principle ensures high availability and reliability,
even during component failures.
Figure~\ref{service_redundancy} depicts all major DESIGN components eligible for redundancy
and which will be briefly described following:
\begin{itemize}
	\item \textbf{Frontend/Backend:}
	      In our final version,
	      redundancy of the frontend and backend components
	      will enable configuration for distributing multiple instances
	      to dedicated systems and utilizing standardized load-balancing strategies.
	      This setup allows the frontend or backend
	      to serve as a gateway between the user and the backend service
	      containing all relevant instances.
	      Both components contribute to redundancy
	      by distributing requests and responses to their respecitive recipients
	      instead of processing them on their own.
	\item \textbf{Instances:} Redundancy of instances
	      It is not a necessary condition for DaaS systems in general,
	      but applying such strategies under certain conditions might be plausible.
	      By using highly available clusters within our backend services
	      redundancy can be achieved by using the corresponding API endpoints
	      previously described and by parameterizing them appropriately.
	\item \textbf{Database:}
	      The database is integrated as a backend service
	      and is therefore independent of surrounding components and contexts.
	      It can be distributed to a dedicated system if necessary.
	      Modern database solutions, like MariaDB,
	      offer rich features for maintaining specific data consistency strategies
	      such as data replication, clustering, failover mechanisms,
	      and RAID control.
	      Currently, redundancies in our database system are not planned
	      but can be easily applied by users using such database-specific features
	      and a modified database adapter.
	\item \textbf{Authentication: }
	      Authentication within our architecture is implemented as a backend service,
	      allowing for distribution to any dedicated system.
	      It can also be targeted by standardized load-balancing mechanisms
	      and remains fully agnostic of surrounding components
	      or calling contexts.
	      The authentication system maintains its credential registry
	      in a separate database, along with a customizable set
	      of user and group privileges.
	      Additionally, it implements the well-defined OAuth 2.0 standard
	      to facilitate remote authentication.
	      In our final version,
	      a customizable amount of redundant systems may be configured.
	\item \textbf{Distributed Filesystem:}
	      Within our architecture, we utilize the distributed filesystem Ceph,
	      which offers object, block, and file storage capabilities.
	      Redundancy in Ceph is implicitly achieved
	      through its self-healing and self-managing features, employing
	      the CRUSH algorithm (Controlled Replication Under Scalable Hashing).
	      Data availability and fault tolerance are ensured
	      by automatically replicating data across different devices.
	      Our architecture leverages these capabilities
	      to reliably provide file storage to host systems
	      and all hosted DaaS instances,
	      while also offering block storage to the infrastructural backend services.
	      Hosting DaaS instances directly from the distributed block storage
	      enables migration and redundancy of instances or in other words, horizontal scaling.
\end{itemize}
\begin{figure}
	\centering
	\begin{adjustbox}{width=\textwidth}
		\begin{tikzpicture}[every node/.style={minimum height=1.5cm, align=center}]
			% Node
			\node[draw, minimum width=4cm, fill=gray!10] (front0) at (-4,-3.0) {DESIGN Frontend};
			\node[draw, minimum width=4cm, fill=gray!30] (back0) at (-4,-4.5) {DESIGN Backend};
			\node[draw, minimum width=4cm, fill=gray!50] (inf0) at (-4,-6.0) {DESIGN Infrastructure};
			\node[draw, minimum width=4cm, fill=gray!10] (db0) at (0,-3.0) {Database};
			\node[draw, minimum width=4cm, fill=gray!30] (auth0) at (0,-4.5) {Authentication};
			\node[draw, minimum width=4cm, fill=gray!50] (fs0) at (0,-6.0) {Storage};
			% Frontends
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!10] (front1) at (-9,-2.5) {Frontend 1};
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!10] (front2) at (-9,-3.0) {Frontend 2};
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!10] (front3) at (-9,-3.5) {Frontend 3};
			\draw[->, dashed, thick, black] (front0.west) -- (front1.east);
			\draw[->, dashed, thick, black] (front0.west) -- (front2.east);
			\draw[->, dashed, thick, black] (front0.west) -- (front3.east);
			% Backends
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!30] (back1) at (-9,-4.0) {Backend 1};
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!30] (back2) at (-9,-4.5) {Backend 2};
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!30] (back3) at (-9,-5.0) {Backend 3};
			\draw[->, dashed, thick, black] (back0.west) -- (back1.east);
			\draw[->, dashed, thick, black] (back0.west) -- (back2.east);
			\draw[->, dashed, thick, black] (back0.west) -- (back3.east);
			% Instances
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!50] (inst1) at (-9,-5.5) {Instances 1};
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!50] (inst2) at (-9,-6.0) {Instances 2};
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!50] (inst3) at (-9,-6.5) {Instances 3};
			\draw[->, dashed, thick, black] (inf0.west) -- (inst1.east);
			\draw[->, dashed, thick, black] (inf0.west) -- (inst2.east);
			\draw[->, dashed, thick, black] (inf0.west) -- (inst3.east);
			% DB
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!10] (db1) at (5,-2.5) {Database 1};
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!10] (db2) at (5,-3.0) {Database 2};
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!10] (db3) at (5,-3.5) {Database 3};
			\draw[->, dashed, thick, black] (db0.east) -- (db1.west);
			\draw[->, dashed, thick, black] (db0.east) -- (db2.west);
			\draw[->, dashed, thick, black] (db0.east) -- (db3.west);
			% Auth
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!30] (auth1) at (5,-4.0) {Authentication 1};
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!30] (auth2) at (5,-4.5) {Authentication 2};
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!30] (auth3) at (5,-5.0) {Authentication 3};
			\draw[->, dashed, thick, black] (auth0.east) -- (auth1.west);
			\draw[->, dashed, thick, black] (auth0.east) -- (auth2.west);
			\draw[->, dashed, thick, black] (auth0.east) -- (auth3.west);
			% Fs
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!50] (fs1) at (5,-5.5) {Storage 1};
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!50] (fs2) at (5,-6.0) {Storage 2};
			\node[draw, minimum width=4cm,minimum height=0.5cm, fill=gray!50] (fs3) at (5,-6.5) {Storage 3};
			\draw[->, dashed, thick, black] (fs0.east) -- (fs1.west);
			\draw[->, dashed, thick, black] (fs0.east) -- (fs2.west);
			\draw[->, dashed, thick, black] (fs0.east) -- (fs3.west);
			% Arrows Bottom
			\draw[<->, thick, black] (-11,-7.5) -- (-2.1,-7.5)node[midway, below, font=\footnotesize] {User-Facing Components};
			\draw[<->, thick, black] (-1.9,-7.5) -- (7,-7.5)node[midway, below, font=\footnotesize] {Service Components};
		\end{tikzpicture}
	\end{adjustbox}
	\caption{DESIGN Component Redundancy}\label{service_redundancy}
\end{figure}

\subsubsection{Internal Communication}
After discussing the principles of scalability and redundancy,
we finally discuss how communication flows are managed in our distributed environment.
Our proposed solution is rooted in a message-oriented architecture
designed to fulfill DaaS properties for scalability and redundancy,
as previously outlined.

This implies that any action triggered, whether in the frontend on the client side,
backend on the host side, or within hosted instances,
must ensure that the necessary information for execution
is readily available at the time of processing.

We achieve this by storing runtime information in distributed block storage,
relevant configuration files in distributed file storage,
object metadata in a common database,
and by utilizing a decentralized OAuth component for authentication.

This ensures that any change triggered by a node within the DaaS domain
is immediately available to any other node relying in some way
on that particular information change.
Additionally, any extra information needed by a component must be fully contained
within the related request or response.
As shown in figure~\ref{message_routing}, this enables arbitrarily distributed configurations as long as request
and response messages reach their desired target eventually
and as long relevant backend services remain available.

If that is the case, each distributed DaaS node might only contain essential and time-critical components,
including the backend service hosting relevant instances as well as the described
websocket proxy connected to the guacamole daemon and the user.
Any other component may reside elsewhere within the DaaS network.

\begin{figure}
	\centering
	\begin{adjustbox}{width=\textwidth}
		\begin{tikzpicture}[every node/.style={minimum width=4cm, minimum height=1cm, align=center}]
			% Frontends
			\node[draw,minimum height=0.5cm, fill=gray!10] (front1) at (-4,0.3) {Frontend 1};
			\node[draw,minimum height=0.5cm, fill=gray!10] (front2) at (0,0.3) {Frontend 2};
			\node[draw,minimum height=0.5cm, fill=gray!10] (front3) at (+4,0.3) {Frontend 3};
			% Backends
			\node[draw,minimum height=0.5cm, fill=gray!30] (back1) at (-4,1.1) {Backend 1};
			\node[draw,minimum height=0.5cm, fill=gray!30] (back2) at (+0,1.1) {Backend 2};
			\node[draw,minimum height=0.5cm, fill=gray!30] (back3) at (+4,1.1) {Backend 3};
			% Instances
			\node[draw,minimum width=12cm, minimum height=1cm, fill=gray!80] (instdomain) at (+0,2.1) {};
			\node[draw,minimum height=0.5cm, fill=gray!80] (inst) at (+0,2) {Instance};
			% Message
			\node[draw,minimum height=0.5cm, fill=gray!50] (message) at (0,-0.75) {Message};
			% Arrows instance
			\draw[->, thick, black] (inst.west) -- ++(-3,0) node[midway, above=-5pt, font=\scriptsize] {Switch to host 1};
			\draw[->, thick, black] (inst.east) -- ++(3,0) node[midway, above=-5pt, font=\scriptsize] {Switch to host 3};
			% Arrows backend
			\draw[->, thick, black] (back1.north) -- ++(0,0.25);
			\draw[->, thick, black] (back2.north) -- ++(0,0.25);
			\draw[->, thick, black] (back3.north) -- ++(0,0.25);
			% Arrows frontend
			\draw[->, thick, black] (front1.north) -- (back1.south);
			% \draw[->, thick, black] (front1.north) -- (back2.south);
			% \draw[->, thick, black] (front1.north) -- (back3.south);
			% \draw[->, thick, black] (front2.north) -- (back1.south);
			\draw[->, thick, black] (front2.north) -- (back2.south);
			% \draw[->, thick, black] (front2.north) -- (back3.south);
			% \draw[->, thick, black] (front3.north) -- (back1.south);
			% \draw[->, thick, black] (front3.north) -- (back2.south);
			\draw[->, thick, black] (front3.north) -- (back3.south);
			% Arrows Message
			\draw[->, thick, black] (message.north) -- (front1.south);
			\draw[->, thick, black] (message.north) -- (front2.south);
			\draw[->, thick, black] (message.north) -- (front3.south);
		\end{tikzpicture}
	\end{adjustbox}
	\caption{Message Oriented Routing.}\label{message_routing}
\end{figure}

\subsection{Usability}
An essential feature of a DaaS platform is its strong user-friendliness,
which eliminates the complexity of the different operating systems
used inside virtual machines and containers,
makes the underlying hardware transparent,
and simplifies the necessary interactions as much as possible.

Since users already have an operating system on their clients,
and the motivation for using a DaaS is the simple use of various applications,
it makes no sense for most users to have additional desktops available in the browser.
The focus should be on the applications.
For this reason, when developing a new DaaS solution,
the main goal should be to reduce the graphical output
to the limits of the respective application.
The concept uses a separate browser tab for each application
whose content exclusively represents the application.

Developing the automatic adaptation of the output
to the limits of the respective application window is challenging.
Only a few RDP and VNC server implementations offer to export the graphical output
of only individual windows or processes.
For Windows operating systems, the proprietary built-in RDP server
and the free software TightVNC offer the export of full desktops and single windows.

For Linux operating system deployments,
the free software projects xrdp and x11vnc enable all desired features
and single-app functionality can be easily obtained
by using a custom window manager such as for example qtile
~\footnote{\url{https://qtile.org/}}.

Table~\ref{tab:DaaS_Services_Overview} includes an overview
of the mentioned service implementations for RDP and VNC protocols
and their relevant characteristics.
Further implementations like TigerVNC and protocols like NX NoMachine exist
but do not seem useful for designing and implementing a novel DaaS because
they do not meet all feature requirements.~\cite{OJCC_2023v8i1n01_Baun}

\begin{table}
	\centering
	\caption{Services used by our DaaS for Remote Access to individual Applications}
	\begin{tabular}{|l|c|c|c|c|}
		\hline
		\textbf{Service}        & \textbf{Protocol} & \textbf{Single Window} & \textbf{Operating} & \textbf{Software} \\
		\textbf{implementation} &                   & \textbf{Mode}          & \textbf{System}    & \textbf{License}  \\
		\hline
		TightVNC                & VNC               & supported              & Windows            & GPL2              \\
		\hline
		Windows RDP server      & RDP               & supported              & Windows            & proprietary       \\
		\hline
		x11vnc                  & VNC               & not supported          & Linux              & GPL2              \\
		\hline
		Xrdp                    & RDP               & supported              & Linux              & Apache 2.0        \\
		\hline
	\end{tabular}
	\label{tab:DaaS_Services_Overview}
\end{table}

The automatic adaptation of viewer size and screen resolution,
considering underlying protocols and systems,
faced various limitations, briefly described below.

One challenge was imposed by Guacamole's current lack of support
for dynamic desktop resizing with VNC,
leading to misaligned layouts and a poor user experience.
To address this until such features are available in Guacamole
\footnote{\url{https://issues.apache.org/jira/browse/GUACAMOLE-1196}},
we implemented a separate mechanism using a websocket proxy
and direct interaction with each instance.

Additionally, protocol-specific behaviors may vary
when hosted on different platforms or infrastructures.
For instance, we observed connection terminations when resizing Linux-based containers,
contrasting with the behavior observed in equivalent Linux-based virtual machines.
To overcome such limitations, we created a separate layer around the Guacamole client,
adapting to each infrastructure, platform, or protocol-specific configuration.

Another challenge was managing RDP sessions which are typically tied to actual users,
unlike VNC sessions which are typically authenticated against
a server-maintained user registry.
Utilizing the websocket proxy, the backend could pass credentials
to the server without revealing them to the user.

Essentially, Guacamole with its protocol implementations and additional features like audio and printing,
provided the fundamental base for our core capabilities.

Finally mentioned, certain instances might not be fully accessible during runtime
due to hardware malfunctions, inappropriate system configurations for simply during system updates.
Therefore, as a failover mechanism additional logic had to be added
in order to provide reasonable debug views and recovery mechanisms,
e.g.~to recreate instances from a specific snapshot or configuration state.

A crucial lesson learned was therefore to realize that
while individual problems can mostly be solved
using established paradigms, services or libraries with only slight modifications,
the real challenge for a full-fledged DaaS system lies in it's abilities
to combining such isolated solutions appropriately
and for each specific infrastructure and platform configuration.

\section{Conclusion and Outlook}
\label{sec:Conclusions}

In this paper, we describe an architecture for a novel and feature-rich DaaS that is, by principle, superior to comparable products and approaches because it supports running unmodified Linux and Windows applications. Furthermore, we identified characteristic issues -- concerning compatibility, performance, stability, and usability -- during the development and implementation of our DaaS and present solutions to overcome these challenges.

% \section{Outlook}
% \label{sec:NextSteps}

For future work, we plan to do a performance analysis that includes an evaluation of different user behaviors for various popular applications and realistic deployment and utilization scenarios.


\section*{Acknowledgements}

This work was funded by the Federal Ministry for Economic Affairs and Climate Action
('\textsl{Bundesministerium f\"ur Wirtschaft und Klimaschutz}')
in the framework of the central innovation programme
for small and medium-sized enterprises
('\textsl{Zentrales Innovationsprogramm Mittelstand}').

We thank our project partners from Nuromedia GmbH for their support.
We especially thank Björn Goetschke, Mike Ludemann, Dario Savella, Holger Sprengel, and Rahul Tomar.



% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\bibliographystyle{splncs04}
\bibliography{biblio}
%

% \bibliography{\jobname_no_dashes_at_repeated_names,references}{}


\end{document}
